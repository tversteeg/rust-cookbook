<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Application development - </title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">

        <!-- MathJax -->
        <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>
    </head>
    <body class="light">
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = localStorage.getItem('theme');
            if (theme == null) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = localStorage.getItem('sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li class="affix"><a href="intro.html">Table of Contents</a></li><li class="affix"><a href="about.html">About</a></li><li><a href="basics.html"><strong>1.</strong> Basics</a></li><li><a href="encoding.html"><strong>2.</strong> Encoding</a></li><li><a href="concurrency.html"><strong>3.</strong> Concurrency</a></li><li><a href="net.html"><strong>4.</strong> Networking</a></li><li><a href="app.html"><strong>5.</strong> Application development</a></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush"></i>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <i id="print-button" class="fa fa-print" title="Print this book"></i>
                    </div>
                </div>

                <div id="content" class="content">
                    <a class="header" href="print.html#cookin-with-rust" id="cookin-with-rust"><h1>Cookin' with Rust</h1></a>
<p>This <em>Rust Cookbook</em> is a collection of
simple examples that demonstrate good practices to accomplish common
programming tasks, using the crates of the Rust ecosystem.</p>
<p><a href="about.html">Read more about <em>Rust Cookbook</em></a>, including tips for
how to read the book, how to use the examples, and notes on conventions.</p>
<a class="header" href="print.html#contributing" id="contributing"><h2>Contributing</h2></a>
<p>This project is intented to be easy for new Rust programmers to
contribute to, and an easy to way get involved with the Rust
community. It needs and welcomes help. For details see
<a href="https://github.com/brson/rust-cookbook/blob/master/CONTRIBUTING.md">CONTRIBUTING.md</a>.</p>
<a class="header" href="print.html#a-hrefbasicshtmlbasicsa" id="a-hrefbasicshtmlbasicsa"><h2><a href="basics.html">Basics</a></h2></a>
<table><thead><tr><td> Recipe </td><td> Crates </td><td> Categories </td></tr></thead>
<tr><td> <a href="basics.html#ex-std-read-lines">Read lines of strings from a file</a> </td><td> <a href="https://doc.rust-lang.org/std"><img src="https://img.shields.io/badge/std-1.17.0-blue.svg" alt="std-badge" /></a> </td><td> <a href="https://crates.io/categories/filesystem"><img src="https://img.shields.io/badge/-filesystem-red.svg" alt="cat-filesystem-badge" /></a> </td></tr>
<tr><td> <a href="basics.html#ex-byteorder-le">Read and write integers in little-endian byte order</a> </td><td> <a href="https://docs.rs/byteorder/"><img src="https://img.shields.io/crates/v/byteorder.svg?label=byteorder" alt="byteorder-badge" /></a> </td><td> <a href="https://crates.io/categories/encoding"><img src="https://img.shields.io/badge/-encoding-red.svg" alt="cat-encoding-badge" /></a> </td></tr>
<tr><td> <a href="basics.html#ex-rand-float">Generate random floating point numbers</a> </td><td> <a href="https://docs.rs/rand/"><img src="https://img.shields.io/crates/v/rand.svg?label=rand" alt="rand-badge" /></a> </td><td> <a href="https://crates.io/categories/science"><img src="https://img.shields.io/badge/-science-red.svg" alt="cat-science-badge" /></a> </td></tr>
<tr><td> <a href="basics.html#ex-rand-custom">Generate random values on a custom type</a> </td><td> <a href="https://docs.rs/rand/"><img src="https://img.shields.io/crates/v/rand.svg?label=rand" alt="rand-badge" /></a> </td><td> <a href="https://crates.io/categories/science"><img src="https://img.shields.io/badge/-science-red.svg" alt="cat-science-badge" /></a> </td></tr>
</table>
<a class="header" href="print.html#a-hrefencodinghtmlencodinga" id="a-hrefencodinghtmlencodinga"><h2><a href="encoding.html">Encoding</a></h2></a>
<table><thead><tr><td> Recipe </td><td> Crates </td><td> Categories </td></tr></thead>
<tr><td> <a href="encoding.html#ex-json-value">Serialize and deserialize unstructured JSON</a> </td><td> <a href="https://docs.serde.rs/serde_json/"><img src="https://img.shields.io/crates/v/serde_json.svg?label=serde_json" alt="serde-json-badge" /></a> </td><td> <a href="https://crates.io/categories/encoding"><img src="https://img.shields.io/badge/-encoding-red.svg" alt="cat-encoding-badge" /></a> </td></tr>
<tr><td> <a href="encoding.html#ex-toml-config">Deserialize a TOML configuration file</a> </td><td> <a href="https://docs.rs/toml/"><img src="https://img.shields.io/crates/v/toml.svg?label=toml" alt="toml-badge" /></a> </td><td> <a href="https://crates.io/categories/encoding"><img src="https://img.shields.io/badge/-encoding-red.svg" alt="cat-encoding-badge" /></a> </td></tr>
</table>
<a class="header" href="print.html#a-hrefconcurrencyhtmlconcurrencya" id="a-hrefconcurrencyhtmlconcurrencya"><h2><a href="concurrency.html">Concurrency</a></h2></a>
<table><thead><tr><td> Recipe </td><td> Crates </td><td> Categories </td></tr></thead>
<tr><td> <a href="concurrency.html#ex-rayon-iter-mut">Mutate the elements of an array in parallel</a> </td><td> <a href="https://docs.rs/rayon/"><img src="https://img.shields.io/crates/v/rayon.svg?label=rayon" alt="rayon-badge" /></a> </td><td> <a href="https://crates.io/categories/concurrency"><img src="https://img.shields.io/badge/-concurrency-red.svg" alt="cat-concurrency-badge" /></a> </td></tr>
</table>
<a class="header" href="print.html#a-hrefnethtmlnetworkinga" id="a-hrefnethtmlnetworkinga"><h2><a href="net.html">Networking</a></h2></a>
<table><thead><tr><td> Recipe </td><td> Crates </td><td> Categories </td></tr></thead>
<tr><td> <a href="net.html#ex-url-parse">Parse a URL from a string to a <code>Url</code> type</a> </td><td> <a href="https://docs.rs/url/"><img src="https://img.shields.io/crates/v/url.svg?label=url" alt="url-badge" /></a> </td><td> <a href="https://crates.io/categories/network-programming"><img src="https://img.shields.io/badge/-net-red.svg" alt="cat-net-badge" /></a> </td></tr>
<tr><td> <a href="net.html#ex-url-base">Create a base URL by removing path segments</a> </td><td> <a href="https://docs.rs/url/"><img src="https://img.shields.io/crates/v/url.svg?label=url" alt="url-badge" /></a> </td><td> <a href="https://crates.io/categories/network-programming"><img src="https://img.shields.io/badge/-net-red.svg" alt="cat-net-badge" /></a> </td></tr>
<tr><td> <a href="net.html#ex-url-new-from-base">Create new URLs from a base URL</a> </td><td> <a href="https://docs.rs/url/"><img src="https://img.shields.io/crates/v/url.svg?label=url" alt="url-badge" /></a> </td><td> <a href="https://crates.io/categories/network-programming"><img src="https://img.shields.io/badge/-net-red.svg" alt="cat-net-badge" /></a> </td></tr>
<tr><td> <a href="net.html#ex-url-origin">Extract the URL origin (scheme / host / port)</a> </td><td> <a href="https://docs.rs/url/"><img src="https://img.shields.io/crates/v/url.svg?label=url" alt="url-badge" /></a> </td><td> <a href="https://crates.io/categories/network-programming"><img src="https://img.shields.io/badge/-net-red.svg" alt="cat-net-badge" /></a> </td></tr>
<tr><td> <a href="net.html#ex-url-rm-frag">Remove fragment identifiers and query pairs from a URL</a> </td><td> <a href="https://docs.rs/url/"><img src="https://img.shields.io/crates/v/url.svg?label=url" alt="url-badge" /></a> </td><td> <a href="https://crates.io/categories/network-programming"><img src="https://img.shields.io/badge/-net-red.svg" alt="cat-net-badge" /></a> </td></tr>
<tr><td> <a href="net.html#ex-url-serialize">Serialize a <code>Url</code></a> </td><td> <a href="https://docs.rs/url/"><img src="https://img.shields.io/crates/v/url.svg?label=url" alt="url-badge" /></a> <a href="https://docs.rs/serde/"><img src="https://img.shields.io/crates/v/serde.svg?label=serde" alt="serde-badge" /></a> </td><td> <a href="https://crates.io/categories/network-programming"><img src="https://img.shields.io/badge/-net-red.svg" alt="cat-net-badge" /></a> <a href="https://crates.io/categories/encoding"><img src="https://img.shields.io/badge/-encoding-red.svg" alt="cat-encoding-badge" /></a></td></tr>
<tr><td> <a href="net.html#ex-url-reqwest">Make a HTTP GET request after parsing a URL</a> </td><td> <a href="https://docs.rs/url/"><img src="https://img.shields.io/crates/v/url.svg?label=url" alt="url-badge" /></a> </td><td> <a href="https://crates.io/categories/network-programming"><img src="https://img.shields.io/badge/-net-red.svg" alt="cat-net-badge" /></a> </td></tr>
</table>
<a class="header" href="print.html#a-hrefapphtmlapplication-developmenta" id="a-hrefapphtmlapplication-developmenta"><h2><a href="app.html">Application development</a></h2></a>
<table><thead><tr><td> Recipe </td><td> Crates </td><td> Categories </td></tr></thead>
<tr><td> <a href="app.html#ex-clap-basic">Parse command line arguments</a> </td><td> <a href="https://docs.rs/clap/"><img src="https://img.shields.io/crates/v/clap.svg?label=clap" alt="clap-badge" /></a> </td><td> <a href="https://crates.io/categories/command-line-interface"><img src="https://img.shields.io/badge/-command_line-red.svg" alt="cat-command-line-badge" /></a> </td></tr>
</table>
<!--
<p>Links, in a few categories. Follow the existing structure.</p>
<p>Individual pages contain a subset of these exact links, depending on
the crates and categories of their examples.</p>
<p>Keep lines sorted.</p>
<p>--&gt;</p>
<!-- Categories -->
<!-- Crates -->
<!-- Examples -->
<a class="header" href="print.html#about-cookin-with-rust" id="about-cookin-with-rust"><h1>About &quot;Cookin' with Rust&quot;</h1></a>
<a class="header" href="print.html#table-of-contents" id="table-of-contents"><h2>Table of contents</h2></a>
<ul>
<li><a href="print.html#who">Who this book is for</a></li>
<li><a href="print.html#reading">How to read this book</a></li>
<li><a href="print.html#examples">How to use the examples</a></li>
<li><a href="print.html#errors">A note about error handling</a></li>
<li><a href="print.html#which-crates">A note about crate representation</a></li>
</ul>
<a class="header" href="print.html#who-this-book-is-for" id="who-this-book-is-for"><h2>Who this book is for</h2></a>
<a class="header" href="print.html#how-to-read-this-book" id="how-to-read-this-book"><h2>How to read this book</h2></a>
<a class="header" href="print.html#how-to-use-the-examples" id="how-to-use-the-examples"><h2>How to use the examples</h2></a>
<a class="header" href="print.html#a-note-about-error-handling" id="a-note-about-error-handling"><h2>A note about error handling</h2></a>
<p>Error handling in Rust is robust when done correctly, but in today's
Rust it requires a fair bit of boilerplate. Because of this one often
sees Rust examples filled with <code>unwrap</code> calls instead of proper error
handling.</p>
<p>Since these recipes are intended to be reused as-is and encourage best
practices, they set up error handling correctly when there are
<code>Result</code> types involved.</p>
<p>The basic pattern we use is to have a <code>fn run() -&gt; Result</code> that acts
like the &quot;real&quot; main function.</p>
<p>The code for this setup generally looks like:</p>
<pre><pre class="playpen"><code class="language-rust">use std::io::{self, Write};

fn run() -&gt; io::Result&lt;()&gt; {
    writeln!(io::stderr(), &quot;hello, world&quot;)?;

    Ok(())
}

fn main() {
    run().unwrap();
}
</code></pre></pre>
<p>and when necessary to reduce boilerplate,
they use the <a href="https://docs.rs/error-chain/">error-chain</a> crate.</p>
<pre><pre class="playpen"><code class="language-rust">use std::net::IpAddr;
use std::str;

#[macro_use]
extern crate error_chain;

error_chain! {
    foreign_links {
        Utf8(std::str::Utf8Error);
        AddrParse(std::net::AddrParseError);
    }
}

fn run() -&gt; Result&lt;()&gt; {
    let bytes = b&quot;2001:db8::1&quot;;

    // Bytes to string.
    let s = str::from_utf8(bytes)?;

    // String to IP address.
    let addr: IpAddr = s.parse()?;

    println!(&quot;{:?}&quot;, addr);
    Ok(())
}

fn main() {
    run().unwrap();
}
</code></pre></pre>
<p>This is using the <code>error_chain!</code> macro to define a custom <code>Error</code> and
<code>Result</code> type, along with an automatic conversion from two standard
library error types. The automatic conversion makes the <code>?</code> operator
work.</p>
<p>For more background on error handling in Rust, read <a href="https://doc.rust-lang.org/book/error-handling.html">this page of the
Rust book</a> and <a href="https://brson.github.io/2016/11/30/starting-with-error-chain">this blog post</a>.</p>
<a class="header" href="print.html#a-note-about-crate-representation" id="a-note-about-crate-representation"><h2>A note about crate representation</h2></a>
<!-- Links-->
<a class="header" href="print.html#basics" id="basics"><h1>Basics</h1></a>
<table><thead><tr><td> Recipe </td><td> Crates </td><td> Categories </td></tr></thead>
<tr><td> <a href="print.html#ex-std-read-lines">Read lines of strings from a file</a> </td><td> <a href="https://doc.rust-lang.org/std"><img src="https://img.shields.io/badge/std-1.17.0-blue.svg" alt="std-badge" /></a> </td><td> <a href="https://crates.io/categories/filesystem"><img src="https://img.shields.io/badge/-filesystem-red.svg" alt="cat-filesystem-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-byteorder-le">Read and write integers in little-endian byte order</a> </td><td> <a href="https://docs.rs/byteorder/"><img src="https://img.shields.io/crates/v/byteorder.svg?label=byteorder" alt="byteorder-badge" /></a> </td><td> <a href="https://crates.io/categories/encoding"><img src="https://img.shields.io/badge/-encoding-red.svg" alt="cat-encoding-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-rand-float">Generate random floating point numbers</a> </td><td> <a href="https://docs.rs/rand/"><img src="https://img.shields.io/crates/v/rand.svg?label=rand" alt="rand-badge" /></a> </td><td> <a href="https://crates.io/categories/science"><img src="https://img.shields.io/badge/-rand-red.svg" alt="cat-science-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-rand-custom">Generate random values of a custom type</a> </td><td> <a href="https://docs.rs/rand/"><img src="https://img.shields.io/crates/v/rand.svg?label=rand" alt="rand-badge" /></a> </td><td> <a href="https://crates.io/categories/science"><img src="https://img.shields.io/badge/-rand-red.svg" alt="cat-science-badge" /></a> </td></tr>
</table>
<p><a name="ex-std-read-lines"></a></p>
<a class="header" href="print.html#read-lines-of-strings-from-a-file" id="read-lines-of-strings-from-a-file"><h2>Read lines of strings from a file</h2></a>
<p><a href="https://doc.rust-lang.org/std"><img src="https://img.shields.io/badge/std-1.17.0-blue.svg" alt="std-badge" /></a> <a href="https://crates.io/categories/filesystem"><img src="https://img.shields.io/badge/-filesystem-red.svg" alt="cat-filesystem-badge" /></a></p>
<p>Writes a three-line message to a file, then reads it back a line at a
time with the <a href="https://doc.rust-lang.org/std/io/struct.Lines.html"><code>Lines</code></a> iterator created by
<a href="https://doc.rust-lang.org/std/io/trait.BufRead.html#method.lines"><code>BufRead::lines</code></a>. <a href="https://doc.rust-lang.org/std/io/trait.BufRead.html"><code>BufRead</code></a> is a trait, and the most common way to
get one is from a <a href="https://doc.rust-lang.org/std/io/struct.BufReader.html"><code>BufReader</code></a>, which is constructed from some type
that implements <a href="https://doc.rust-lang.org/std/io/trait.Write.html"><code>Write</code></a>, here a <a href="https://doc.rust-lang.org/std/fs/struct.File.html"><code>File</code></a>. The <a href="https://doc.rust-lang.org/std/fs/struct.File.html"><code>File</code></a> is opened
for writing with <a href="https://doc.rust-lang.org/std/fs/struct.File.html#method.create"><code>File::create</code></a>, and reading with <a href="https://doc.rust-lang.org/std/fs/struct.File.html#method.open"><code>File::open</code></a>.</p>
<pre><pre class="playpen"><code class="language-rust">use std::fs::File;
use std::io::{self, Write, BufReader, BufRead};

fn run() -&gt; io::Result&lt;()&gt; {
    let path = &quot;lines.txt&quot;;

    let mut output = File::create(path)?;
    write!(output, &quot;Rust\n💖\nFun&quot;)?;

    let input = File::open(path)?;
    let buffered = BufReader::new(input);

    for line in buffered.lines() {
        println!(&quot;{}&quot;, line?);
    }

    Ok(())
}

fn main() {
    run().unwrap();
}
</code></pre></pre>
<p><a name="ex-byteorder-le"></a></p>
<a class="header" href="print.html#read-and-write-integers-in-little-endian-byte-order" id="read-and-write-integers-in-little-endian-byte-order"><h2>Read and write integers in little-endian byte order</h2></a>
<p><a href="https://docs.rs/byteorder/"><img src="https://img.shields.io/crates/v/byteorder.svg?label=byteorder" alt="byteorder-badge" /></a> <a href="https://crates.io/categories/encoding"><img src="https://img.shields.io/badge/-encoding-red.svg" alt="cat-encoding-badge" /></a></p>
<pre><pre class="playpen"><code class="language-rust">extern crate byteorder;

use std::io;

use byteorder::{LittleEndian, ReadBytesExt, WriteBytesExt};

#[derive(Default, PartialEq, Debug)]
struct Payload {
    kind: u8,
    value: u16,
}

fn run() -&gt; io::Result&lt;()&gt; {
    let original_payload = Payload::default();
    let encoded_bytes = encode(&amp;original_payload)?;
    let decoded_payload = decode(&amp;encoded_bytes)?;
    assert_eq!(original_payload, decoded_payload);
    Ok(())
}

fn encode(payload: &amp;Payload) -&gt; io::Result&lt;Vec&lt;u8&gt;&gt; {
    let mut bytes = vec![];
    bytes.write_u8(payload.kind)?;
    bytes.write_u16::&lt;LittleEndian&gt;(payload.value)?;
    Ok(bytes)
}

fn decode(mut bytes: &amp;[u8]) -&gt; io::Result&lt;Payload&gt; {
    let payload = Payload {
        kind: bytes.read_u8()?,
        value: bytes.read_u16::&lt;LittleEndian&gt;()?,
    };
    Ok(payload)
}

fn main() {
    run().unwrap();
}
</code></pre></pre>
<p><a name="ex-rand-float"></a></p>
<a class="header" href="print.html#generate-random-floating-point-numbers" id="generate-random-floating-point-numbers"><h2>Generate random floating point numbers</h2></a>
<p><a href="https://docs.rs/rand/"><img src="https://img.shields.io/crates/v/rand.svg?label=rand" alt="rand-badge" /></a> <a href="https://crates.io/categories/science"><img src="https://img.shields.io/badge/-rand-red.svg" alt="cat-science-badge" /></a></p>
<pre><pre class="playpen"><code class="language-rust">extern crate rand;
use rand::Rng;

fn main() {
    let mut rng = rand::thread_rng();
    println!(&quot;Random f64: {}&quot;, rng.gen::&lt;f64&gt;());
}
</code></pre></pre>
<p><a name="ex-rand-custom"></a></p>
<a class="header" href="print.html#generate-random-values-of-a-custom-type" id="generate-random-values-of-a-custom-type"><h2>Generate random values of a custom type</h2></a>
<p><a href="https://docs.rs/rand/"><img src="https://img.shields.io/crates/v/rand.svg?label=rand" alt="rand-badge" /></a> <a href="https://crates.io/categories/science"><img src="https://img.shields.io/badge/-rand-red.svg" alt="cat-science-badge" /></a></p>
<p>A tuple <code>(i32, bool, f64)</code> and variable of user defined type <code>Point</code>
are randomly generated. In order to alow random generation of <code>Point</code>
it needs to implement the <a href="https://doc.rust-lang.org/rand/rand/trait.Rand.html"><code>rand::Rand</code></a> trait.</p>
<pre><pre class="playpen"><code class="language-rust">extern crate rand;
use rand::{Rng, Rand};

#[derive(Debug)]
struct Point {
    x: i32,
    y: i32,
}

impl Rand for Point {
    fn rand&lt;R: Rng&gt;(rng: &amp;mut R) -&gt; Point {
        let (rand_x, rand_y) = rng.gen();
        Point { x: rand_x, y: rand_y }
    }
}

fn main() {
    let mut rng = rand::thread_rng();
    let rand_tuple = rng.gen::&lt;(i32, bool, f64)&gt;();
    let rand_point: Point = rng.gen();
    println!(&quot;Random tuple: {:?}&quot;, rand_tuple);
    println!(&quot;Random Point: {:?}&quot;, rand_point);
}
</code></pre></pre>
<!-- Categories -->
<!-- Crates -->
<!-- API links -->
<a class="header" href="print.html#encoding" id="encoding"><h1>Encoding</h1></a>
<table><thead><tr><td> Recipe </td><td> Crates </td></tr></thead>
<tr><td> <a href="print.html#ex-json-value">Serialize and deserialize unstructured JSON</a> </td><td> <a href="https://docs.serde.rs/serde_json/"><img src="https://img.shields.io/crates/v/serde_json.svg?label=serde_json" alt="serde-json-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-toml-config">Deserialize a TOML configuration file</a> </td><td> <a href="https://docs.rs/toml/"><img src="https://img.shields.io/crates/v/toml.svg?label=toml" alt="toml-badge" /></a> </td></tr>
</table>
<p><a name="ex-json-value"></a></p>
<a class="header" href="print.html#serialize-and-deserialize-unstructured-json" id="serialize-and-deserialize-unstructured-json"><h2>Serialize and deserialize unstructured JSON</h2></a>
<p><a href="https://docs.serde.rs/serde_json/"><img src="https://img.shields.io/crates/v/serde_json.svg?label=serde_json" alt="serde-json-badge" /></a></p>
<p>The <a href="https://docs.serde.rs/serde_json/"><code>serde_json</code></a> crate provides a <a href="https://docs.serde.rs/serde_json/fn.from_str.html"><code>from_str</code></a> function to parse a <code>&amp;str</code> of
JSON into a type of the caller's choice.</p>
<p>Unstructured JSON can be parsed into a universal <a href="https://docs.serde.rs/serde_json/enum.Value.html"><code>serde_json::Value</code></a> type that
is able to represent any valid JSON data.</p>
<p>The example below shows a <code>&amp;str</code> of JSON being parsed and then compared to what
we expect the parsed value to be. The expected value is declared using the
<a href="https://docs.serde.rs/serde_json/macro.json.html"><code>json!</code></a> macro.</p>
<pre><pre class="playpen"><code class="language-rust">#[macro_use]
extern crate serde_json;

use serde_json::Value;

fn main() {
    let j = r#&quot;{
                 &quot;userid&quot;: 103609,
                 &quot;verified&quot;: true,
                 &quot;access_privileges&quot;: [
                   &quot;user&quot;,
                   &quot;admin&quot;
                 ]
               }&quot;#;

    let parsed: Value = serde_json::from_str(j).unwrap();

    let expected = json!({
        &quot;userid&quot;: 103609,
        &quot;verified&quot;: true,
        &quot;access_privileges&quot;: [
            &quot;user&quot;,
            &quot;admin&quot;
        ]
    });

    assert_eq!(parsed, expected);
}
</code></pre></pre>
<p><a name="ex-toml-config"></a></p>
<a class="header" href="print.html#deserialize-a-toml-configuration-file" id="deserialize-a-toml-configuration-file"><h2>Deserialize a TOML configuration file</h2></a>
<p><a href="https://docs.rs/toml/"><img src="https://img.shields.io/crates/v/toml.svg?label=toml" alt="toml-badge" /></a></p>
<p>Parse some TOML into a universal <code>toml::Value</code> that is able to represent any
valid TOML data.</p>
<pre><pre class="playpen"><code class="language-rust">extern crate toml;

use toml::Value;

fn main() {
    let toml_content = r#&quot;
          [package]
          name = &quot;your_package&quot;
          version = &quot;0.1.0&quot;
          authors = [&quot;You! &lt;you@example.org&gt;&quot;]

          [dependencies]
          serde = &quot;1.0&quot;
          &quot;#;

    let package_info: Value = toml::from_str(toml_content).unwrap();

    assert_eq!(package_info[&quot;dependencies&quot;][&quot;serde&quot;].as_str(), Some(&quot;1.0&quot;));
    assert_eq!(package_info[&quot;package&quot;][&quot;name&quot;].as_str(), Some(&quot;your_package&quot;));
}
</code></pre></pre>
<p>Parse TOML into your own structs using Serde:</p>
<pre><pre class="playpen"><code class="language-rust">#[macro_use]
extern crate serde_derive;

extern crate serde;
extern crate toml;

use std::collections::HashMap;

#[derive(Deserialize)]
struct Config {
    package: Package,
    dependencies: HashMap&lt;String, String&gt;,
}

#[derive(Deserialize)]
struct Package {
    name: String,
    version: String,
    authors: Vec&lt;String&gt;,
}

fn main() {
    let toml_content = r#&quot;
          [package]
          name = &quot;your_package&quot;
          version = &quot;0.1.0&quot;
          authors = [&quot;You! &lt;you@example.org&gt;&quot;]

          [dependencies]
          serde = &quot;1.0&quot;
          &quot;#;

    let package_info: Config = toml::from_str(toml_content).unwrap();

    assert_eq!(package_info.package.name, &quot;your_package&quot;);
    assert_eq!(package_info.package.version, &quot;0.1.0&quot;);
    assert_eq!(package_info.package.authors, vec![&quot;You! &lt;you@example.org&gt;&quot;]);
    assert_eq!(package_info.dependencies[&quot;serde&quot;], &quot;1.0&quot;);
}
</code></pre></pre>
<!-- Crates -->
<a class="header" href="print.html#concurrency" id="concurrency"><h1>Concurrency</h1></a>
<table><thead><tr><td> Recipe </td><td> Crates </td></tr></thead>
<tr><td> <a href="print.html#ex-rayon-iter-mut">Mutate the elements of an array in parallel</a> </td><td> <a href="https://docs.rs/rayon/"><img src="https://img.shields.io/crates/v/rayon.svg?label=rayon" alt="rayon-badge" /></a> </td></tr>
</table>
<p><a name="ex-rayon-iter-mut"></a></p>
<a class="header" href="print.html#mutate-the-elements-of-an-array-in-parallel" id="mutate-the-elements-of-an-array-in-parallel"><h2>Mutate the elements of an array in parallel</h2></a>
<p><a href="https://docs.rs/rayon/"><img src="https://img.shields.io/crates/v/rayon.svg?label=rayon" alt="rayon-badge" /></a></p>
<pre><pre class="playpen"><code class="language-rust">extern crate rayon;

use rayon::prelude::*;

fn main() {
    let mut arr = [0, 7, 9, 11];

    arr.par_iter_mut().for_each(|p| *p -= 1);

    println!(&quot;{:?}&quot;, arr);
}
</code></pre></pre>
<p>The example uses the Rayon crate, which is a data parallelism library for Rust.
Rayon provides the <code>par_iter_mut()</code> method for any parallel iterable data type.
It lets us write iterator-like chains that execute in parallel.</p>
<!-- Crates -->
<a class="header" href="print.html#networking" id="networking"><h1>Networking</h1></a>
<table><thead><tr><td> Recipe </td><td> Crates </td><td> Categories </td></tr></thead>
<tr><td> <a href="print.html#ex-url-parse">Parse a URL from a string to a <code>Url</code> type</a> </td><td> <a href="https://docs.rs/url/"><img src="https://img.shields.io/crates/v/url.svg?label=url" alt="url-badge" /></a> </td><td> <a href="https://crates.io/categories/network-programming"><img src="https://img.shields.io/badge/-net-red.svg" alt="cat-net-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-url-base">Create a base URL by removing path segments</a> </td><td> <a href="https://docs.rs/url/"><img src="https://img.shields.io/crates/v/url.svg?label=url" alt="url-badge" /></a> </td><td> <a href="https://crates.io/categories/network-programming"><img src="https://img.shields.io/badge/-net-red.svg" alt="cat-net-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-url-new-from-base">Create new URLs from a base URL</a> </td><td> <a href="https://docs.rs/url/"><img src="https://img.shields.io/crates/v/url.svg?label=url" alt="url-badge" /></a> </td><td> <a href="https://crates.io/categories/network-programming"><img src="https://img.shields.io/badge/-net-red.svg" alt="cat-net-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-url-origin">Extract the URL origin (scheme / host / port)</a> </td><td> <a href="https://docs.rs/url/"><img src="https://img.shields.io/crates/v/url.svg?label=url" alt="url-badge" /></a> </td><td> <a href="https://crates.io/categories/network-programming"><img src="https://img.shields.io/badge/-net-red.svg" alt="cat-net-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-url-rm-frag">Remove fragment identifiers and query pairs from a URL</a> </td><td> <a href="https://docs.rs/url/"><img src="https://img.shields.io/crates/v/url.svg?label=url" alt="url-badge" /></a> </td><td> <a href="https://crates.io/categories/network-programming"><img src="https://img.shields.io/badge/-net-red.svg" alt="cat-net-badge" /></a> </td></tr>
<tr><td> <a href="print.html#ex-url-serialize">Serialize a <code>Url</code></a> </td><td> <a href="https://docs.rs/url/"><img src="https://img.shields.io/crates/v/url.svg?label=url" alt="url-badge" /></a> <a href="https://docs.rs/serde/"><img src="https://img.shields.io/crates/v/serde.svg?label=serde" alt="serde-badge" /></a> </td><td> <a href="https://crates.io/categories/network-programming"><img src="https://img.shields.io/badge/-net-red.svg" alt="cat-net-badge" /></a> <a href="https://crates.io/categories/encoding"><img src="https://img.shields.io/badge/-encoding-red.svg" alt="cat-encoding-badge" /></a></td></tr>
<tr><td> <a href="print.html#ex-url-reqwest">Make a HTTP GET request after parsing a URL</a> </td><td> <a href="https://docs.rs/url/"><img src="https://img.shields.io/crates/v/reqwest.svg?label=reqwest" alt="reqwest-badge" /></a> <a href="https://docs.rs/url/"><img src="https://img.shields.io/crates/v/url.svg?label=url" alt="url-badge" /></a> </td><td> <a href="https://crates.io/categories/network-programming"><img src="https://img.shields.io/badge/-net-red.svg" alt="cat-net-badge" /></a> </td></tr>
</table>
<p><a name="ex-url-parse"/></p>
<a class="header" href="print.html#parse-a-url-from-a-string-to-a-url-type" id="parse-a-url-from-a-string-to-a-url-type"><h2>Parse a URL from a string to a <code>Url</code> type</h2></a>
<p><a href="https://docs.rs/url/"><img src="https://img.shields.io/crates/v/url.svg?label=url" alt="url-badge" /></a> <a href="https://crates.io/categories/network-programming"><img src="https://img.shields.io/badge/-net-red.svg" alt="cat-net-badge" /></a></p>
<p>The <a href="https://docs.rs/url/1.*/url/struct.Url.html#method.parse"><code>parse</code></a> method from the <code>url</code> crate validates and parses a <code>&amp;str</code> into a
<a href="https://docs.rs/url/1.*/url/struct.Url.html"><code>Url</code></a> struct. The input string may be malformed so this method returns
<code>Result&lt;Url, ParseError&gt;</code>.</p>
<p>Once the URL has been parsed, it can be used with all of the methods on the
<code>Url</code> type.</p>
<p>The URL in this code parses successfully, but swapping it out for a malformed
URL will print a message containing an explanation of what went wrong.</p>
<pre><pre class="playpen"><code class="language-rust">extern crate url;

use url::Url;

fn main() {
    let s = &quot;https://github.com/rust-lang/rust/issues?labels=E-easy&amp;state=open&quot;;

    match Url::parse(s) {
        Ok(url) =&gt; {
            println!(&quot;Successfully parsed the URL.&quot;);
            println!(&quot;The path part of the URL is: {}&quot;, url.path());
        }
        Err(err) =&gt; {
            println!(&quot;Failed to parse the URL: {}&quot;, err);
        }
    }
}
</code></pre></pre>
<p><a name="ex-url-base"></a></p>
<a class="header" href="print.html#create-a-base-url-by-removing-path-segments" id="create-a-base-url-by-removing-path-segments"><h2>Create a base URL by removing path segments</h2></a>
<p><a href="https://docs.rs/url/"><img src="https://img.shields.io/crates/v/url.svg?label=url" alt="url-badge" /></a></p>
<pre><pre class="playpen"><code class="language-rust">extern crate url;

use url::{Url, ParseError};

#[macro_use]
extern crate error_chain;

error_chain! {
    errors {
        CannotBeABase
    }
    foreign_links {
        Parse(ParseError);
    }
}

fn main() {
    let s = &quot;https://github.com/rust-lang/cargo?asdf&quot;;

    match base_url(s) {
        Ok(base) =&gt; {
            assert_eq!(base.as_str(), &quot;https://github.com/&quot;);
            println!(&quot;The base of the URL is: {}&quot;, base);
        }
        Err(err) =&gt; {
            println!(&quot;Failed to extract base URL: {}&quot;, err);
        }
    }
}

/// Returns the base of the given URL - the part not including any path segments
/// and query parameters.
fn base_url(full: &amp;str) -&gt; Result&lt;Url&gt; {
    let mut url = Url::parse(full)?;

    // Clear path segments.
    match url.path_segments_mut() {
        Ok(mut path) =&gt; {
            path.clear();
        }
        Err(_) =&gt; {
            // Certain URLs cannot be turned into a base URL.
            return Err(Error::from_kind(ErrorKind::CannotBeABase));
        }
    }

    // Clear query parameters.
    url.set_query(None);

    Ok(url)
}
</code></pre></pre>
<p><a name="ex-url-new-from-base"></a></p>
<a class="header" href="print.html#create-new-urls-from-a-base-url" id="create-new-urls-from-a-base-url"><h2>Create new URLs from a base URL</h2></a>
<p>The <a href="https://docs.rs/url/1.*/url/struct.Url.html#method.join"><code>join</code></a> method creates a new URL from a base and relative path.</p>
<pre><pre class="playpen"><code class="language-rust">extern crate url;

use url::{Url, ParseError};

fn main() {
    let path = &quot;/rust-lang/cargo&quot;;

    match build_github_url(path) {
        Ok(url) =&gt; {
            assert_eq!(url.as_str(), &quot;https://github.com/rust-lang/cargo&quot;);
            println!(&quot;The joined URL is: {}&quot;, url);
        }
        Err(err) =&gt; {
            println!(&quot;Failed to build GitHub URL: {}&quot;, err);
        }
    }
}

fn build_github_url(path: &amp;str) -&gt; Result&lt;Url, ParseError&gt; {
    // Hardcoded in our program. Caller's path will be joined to this.
    const GITHUB: &amp;'static str = &quot;https://github.com&quot;;

    let base = Url::parse(GITHUB).expect(&quot;hardcoded URL is known to be valid&quot;);
    base.join(path)
}
</code></pre></pre>
<p><a name="ex-url-origin"></a></p>
<a class="header" href="print.html#extract-the-url-origin-scheme--host--port" id="extract-the-url-origin-scheme--host--port"><h2>Extract the URL origin (scheme / host / port)</h2></a>
<p>The <a href="https://docs.rs/url/1.*/url/struct.Url.html"><code>Url</code></a> struct exposes various methods to extract information about the URL
it represents.</p>
<pre><pre class="playpen"><code class="language-rust">extern crate url;

use url::{Url, Host};

fn main() {
    let s = &quot;ftp://rust-lang.org/examples&quot;;

    match Url::parse(s) {
        Ok(url) =&gt; {
            assert_eq!(url.scheme(), &quot;ftp&quot;);
            assert_eq!(url.host(), Some(Host::Domain(&quot;rust-lang.org&quot;)));
            assert_eq!(url.port_or_known_default(), Some(21));
            println!(&quot;The origin is as expected!&quot;);
        }
        Err(err) =&gt; {
            println!(&quot;Failed to parse the URL: {}&quot;, err);
        }
    }
}
</code></pre></pre>
<p>The same result can be obtained using the <a href="https://docs.rs/url/1.*/url/struct.Url.html#method.origin"><code>origin</code></a> method as well.</p>
<pre><pre class="playpen"><code class="language-rust">extern crate url;

use url::{Url, Origin, Host};

fn main() {
    let s = &quot;ftp://rust-lang.org/examples&quot;;

    match Url::parse(s) {
        Ok(url) =&gt; {
            let expected_scheme = &quot;ftp&quot;.to_owned();
            let expected_host = Host::Domain(&quot;rust-lang.org&quot;.to_owned());
            let expected_port = 21;
            let expected = Origin::Tuple(expected_scheme, expected_host, expected_port);

            let origin = url.origin();
            assert_eq!(origin, expected);
            println!(&quot;The origin is as expected!&quot;);
        }
        Err(err) =&gt; {
            println!(&quot;Failed to parse the URL: {}&quot;, err);
        }
    }
}
</code></pre></pre>
<p><a name="ex-url-rm-frag"></a></p>
<a class="header" href="print.html#remove-fragment-identifiers-and-query-pairs-from-a-url" id="remove-fragment-identifiers-and-query-pairs-from-a-url"><h2>Remove fragment identifiers and query pairs from a URL</h2></a>
<p><a href="https://github.com/brson/rust-cookbook/issues/37">Write me!</a></p>
<p><a name="ex-url-serialize"></a></p>
<a class="header" href="print.html#serialize-a-url" id="serialize-a-url"><h2>Serialize a <code>Url</code></h2></a>
<p><a href="https://github.com/brson/rust-cookbook/issues/38">Write me!</a></p>
<p><a name="ex-url-reqwest"></a></p>
<a class="header" href="print.html#make-a-http-get-request-after-parsing-a-url" id="make-a-http-get-request-after-parsing-a-url"><h2>Make a HTTP GET request after parsing a URL</h2></a>
<p><a href="https://github.com/brson/rust-cookbook/issues/39">Write me!</a></p>
<!-- Categories -->
<!-- Crates -->
<!-- Reference -->
<a class="header" href="print.html#application-development" id="application-development"><h1>Application development</h1></a>
<table><thead><tr><td> Recipe </td><td> Crates </td></tr></thead>
<tr><td> <a href="print.html#ex-clap-basic">Parse command line arguments</a> </td><td> <a href="https://docs.rs/clap/"><img src="https://img.shields.io/crates/v/clap.svg?label=clap" alt="clap-badge" /></a> </td></tr>
</table>
<p><a name="ex-clap-basic"></a></p>
<a class="header" href="print.html#parse-command-line-arguments" id="parse-command-line-arguments"><h2>Parse command line arguments</h2></a>
<p><a href="https://docs.rs/clap/"><img src="https://img.shields.io/crates/v/clap.svg?label=clap" alt="clap-badge" /></a></p>
<pre><pre class="playpen"><code class="language-rust">extern crate clap;

use clap::{Arg, App};

fn main() {
    // Define command line arguments.
    let matches = App::new(&quot;My Test Program&quot;)
        .version(&quot;0.1.0&quot;)
        .author(&quot;Hackerman Jones &lt;hckrmnjones@hack.gov&gt;&quot;)
        .about(&quot;Teaches argument parsing&quot;)
        .arg(Arg::with_name(&quot;file&quot;)
                 .short(&quot;f&quot;)
                 .long(&quot;file&quot;)
                 .takes_value(true)
                 .help(&quot;A cool file&quot;))
        .arg(Arg::with_name(&quot;num&quot;)
                 .short(&quot;n&quot;)
                 .long(&quot;number&quot;)
                 .takes_value(true)
                 .help(&quot;Five less than your favorite number&quot;))
        .get_matches();

    // Get value for file, or default to 'input.txt'.
    let myfile = matches.value_of(&quot;file&quot;).unwrap_or(&quot;input.txt&quot;);
    println!(&quot;The file passed is: {}&quot;, myfile);

    // Get value for num if present, and try parsing it as i32.
    let num_str = matches.value_of(&quot;num&quot;);
    match num_str {
        None =&gt; println!(&quot;No idea what your favorite number is.&quot;),
        Some(s) =&gt; {
            match s.parse::&lt;i32&gt;() {
                Ok(n) =&gt; println!(&quot;Your favorite number must be {}.&quot;, n + 5),
                Err(_) =&gt; println!(&quot;That's not a number! {}&quot;, s),
            }
        }
    }
}
</code></pre></pre>
<p>The <code>clap</code> crate is a simple-to-use, efficient, and full-featured library for
parsing command line arguments and subcommands when writing console/terminal
applications.</p>
<p>The application can describe the structure of its command-line interface using
<code>clap</code>'s builder style. The <a href="https://docs.rs/clap/">documentation</a> gives two other possible ways to
instantiate an application.</p>
<p>In the builder style, <code>with_name</code> is the unique identifier that <code>value_of</code> will
use to retrieve the value passed. The <code>short</code> and <code>long</code> options control the
flag the user will be expected to type; short flags look like <code>-f</code> and long
flags look like <code>--file</code>.</p>
<p>Usage information is generated by <code>clap</code>. The usage for the example application
looks like this.</p>
<pre><code>My Test Program 0.1.0
Hackerman Jones &lt;hckrmnjones@hack.gov&gt;
Teaches argument parsing

USAGE:
    testing [OPTIONS]

FLAGS:
    -h, --help       Prints help information
    -V, --version    Prints version information

OPTIONS:
    -f, --file &lt;file&gt;     A cool file
    -n, --number &lt;num&gt;    Five less than your favorite number
</code></pre>
<p>We can test the application by running a command like the following.</p>
<pre><code>$ cargo run -- -f myfile.txt -n 251
</code></pre>
<p>The output is:</p>
<pre><code>The file passed is: myfile.txt
Your favorite number must be 256.
</code></pre>
<!-- Crates -->

                </div>

                <!-- Mobile navigation buttons -->
                

                

            </div>

            

            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <!-- Livereload script (if served using the cli tool) -->
        

        <script src="highlight.js"></script>
        <script src="book.js"></script>
    </body>
</html>
